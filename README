------------------------------------------------------------------------
                 FPS : Fast, packed strings
------------------------------------------------------------------------

This library provides the Data.ByteString library: byte arrays
manipulable as strings, providing very time and space efficient string
and IO operations.

Requirements:
        > Cabal
        > GHC 6.4 or greater, or hugs Mar-2005

Building:
        > chmod +x Setup.hs
        > ./Setup.hs configure --prefix=/f/g
        > ./Setup.hs build
        > ./Setup.hs install

After installation, you can run the testsuite as follows:
    
        > cd tests ; runghc Quick.hs
    or
        > cd tests ; runhugs Quick.hs

For the full test and benchmark suite, you need GHC:

        > cd tests ; chmod +x logpp ; make ; make run

You may need to edit the Makefile if your version of the m4 preprocessor isn't 'gm4'

Authors:
    ByteString is derived from the GHC PackedString library, 
    originallly written by Bryan O'Sullivan, and then by Simon Marlow.
    It was adapted, and greatly extended for darcs by David Roundy, and
    others. Don Stewart cleaned up and further extended the implementation.

------------------------------------------------------------------------

Performance, some random numbers (with GHC):

This table compares the performance of common operations ByteString,
from various string libraries.

Size of test data: 21256k, Linux 3.2Ghz P4

                          FPS6       SPS     PS      [a]    
++                        0.028      !       !       1.288   
length                    0.000      0.000   0.000   0.131   
pack                      0.303      0.502   0.337   -       
unpack                    3.319*     1.630   7.445   -       
compare                   0.000      0.000   0.000   0.000   
index                     0.000      0.000   0.000   0.000   
map                       2.762*     2.917   4.813   7.286   
filter                    0.260      2.805   0.954   0.305   
take                      0.000      0.000   0.024   0.005   
drop                      0.000      0.000   11.768  0.130   
takeWhile                 0.000      1.498   0.000   0.000   
dropWhile                 0.000      1.985   8.447   0.130   
span                      0.000      9.289   11.144  0.131   
break                     0.000      9.383   11.268  0.133   
lines                     0.052      1.114   1.367   2.790   
unlines                   0.120      !       !       10.950  
words                     1.583      2.128   5.644   4.184   
unwords                   0.058      !       !       1.305   
reverse                   0.024      12.997  13.018  1.622   
concat                    0.000      12.701  11.459  1.163   
cons                      0.016      2.064   8.358   0.131   
empty                     0.000      0.000   0.000   0.000   
head                      0.000      0.000   0.000   0.000   
tail                      0.000      0.000   14.490  0.130   
elem                      0.000      1.490   0.001   0.000   
last                      0.000      -       -       0.143   
init                      0.000      -       -       1.147   
inits                     0.414      -       -       !       
tails                     0.460      -       -       1.136   
intersperse               0.070*     -       -       10.517  
any                       0.000      -       -       0.000   
all                       0.000      -       -       0.000   
sort                      0.168      -       -       !
maximum                   0.024      -       -       0.183
minimum                   0.025      -       -       0.185
replicate                 0.000      -       -       0.053   
find                      0.259      -       -       0.000   
elemIndex                 0.000      -       -       0.000   
elemIndicies              0.010      -       -       0.314   
filterChar                0.031      
filterNotChar             0.202      
join                      0.029      
split                     0.071      
snoc                      0.017
findIndices               0.408      
splitAt                   0.000      
lineIndices               0.029      
breakOn                   0.000      
breakSpace                0.000 
splitWith                 0.329 
dropSpace                 0.000 
dropSpaceEnd              0.000 
joinWithChar              0.017
join /                    0.030 
zip                       0.960 
zipWith                   0.892 
isSubstringOf             0.039 
isPrefixOf                0.000 
isSuffixOf                0.000
count                     0.021

Key: FPS6 = FPS 0.6
     SPS  = Simon Marlow's packedstring prototype
     PS   = Data.PackedString
     [a]  = [Char]

     -    = no function exists
     !    = stack or memory exhaustion

------------------------------------------------------------------------

Question:
    Can I manipulate 1G strings in Haskell?

Short answer:
    Yes! Mostly.

Doing some stress testing of FPS, here are some results for 1G strings.

3.2Ghz box, 2G physical mem.
Size of input string: 1G

N.B. 2G of physical ram is not enough when trying to benchmark functions
that copy 1G strings around :)

    Function        Time in seconds

All O(1) functions:
    length          O
    index           0
    head            0
    tail            0
    last            0
    init            0

O(n) , but answer found early on:
    compare         0           
    any             0
    all             0
    elem            0
    elemIndex       0

O(n) mostly:
    maximum         3.855    
    minimum         4.666   
    filterChar      8.084   
    elemIndicies    11.504  
    lines           12.247  
    find            14.046  
    tails           27.328
    inits           33.620  
    words           100.963
    map toUpper     143.871

Failed due to memory exhaustion. 
Almost made it though, just need a tad more ram than I had.

    filter          !     
    unlines         !
    unwords         !
    reverse         !           -- copy
    cons            !           -- copy
    snoc            !           -- involves a copy
    ++              !           -- can't concat two 1G strings on this box

    sort            ? taking too long, but space was ok.

[Char] functions are much more costly.
    pack            !           -- constructing 1G [Char] is not ok.
    unpack          !            

Transforming 1 0.5G string into another requires holding both in memory:

Fine:
    filter          7.264
    unwords         1.715
    reverse         1.980
    cons            0.976
    snoc            0.689
    ++              2.845

Still wouldn't work at 0.5G
    unlines         !
    concat          !

Lesssons, you can play with 1G strings in Haskell. Having more than 2G
ram is useful though. Replacing higher order functions with hard coded
first order equivalents can help.

